# Import necessary libraries
import pandas as pd
from datetime import datetime, timedelta
from typing import List, Dict, Tuple, Set
from collections import defaultdict
import random

class ScholarXScheduler:
    """
    ScholarX Team Scheduling Algorithm - Optimized for finding meeting times for specific teams
    
    This class analyzes student availability and skills for pre-formed teams to:
    1. Find optimal meeting times for a specific group of students
    2. Calculate skill compatibility within the team
    3. Suggest best time slots based on team availability
    """
    
    def __init__(self):
        """Initialize the ScholarX Scheduling Algorithm"""
        self.students_data = []
        self.time_slots = self._generate_time_slots()
        self.supported_days = ['monday', 'tuesday', 'wednesday', 'thursday', 'friday', 'saturday', 'sunday']
        
    def _generate_time_slots(self) -> List[str]:
        """Generate all possible time slots from 09:00 to 23:59"""
        slots = []
        for hour in range(9, 24):
            slots.append(f"{hour:02d}:00 - {hour+1:02d}:00")
        return slots
    
    def _parse_unavailable_times(self, time_string: str) -> Set[str]:
        """Parse unavailable time slots from string format"""
        if pd.isna(time_string) or not time_string.strip():
            return set()
        
        unavailable_slots = set()
        slots = time_string.split(',')
        for slot in slots:
            slot = slot.strip()
            if slot:
                unavailable_slots.add(slot)
        return unavailable_slots
    
    def _parse_skills(self, skills_string: str) -> List[str]:
        """Parse skills from comma-separated string format"""
        if pd.isna(skills_string) or not skills_string.strip():
            return []
        return [skill.strip() for skill in skills_string.split(',') if skill.strip()]
    
    def load_student_data(self, data: List[Dict]):
        """Load student data from a list of dictionaries"""
        self.students_data = []
        
        for student in data:
            student_profile = {
                'student_id': student.get('student_id', f'S{len(self.students_data)+1:03d}'),
                'name': student.get('name', f'Student {len(self.students_data)+1}'),
                'proficient_skills': self._parse_skills(student.get('proficient_skills', '')),
                'intermediate_skills': self._parse_skills(student.get('intermediate_skills', '')),
                'beginner_skills': self._parse_skills(student.get('beginner_skills', ''))
            }
            
            # Add unavailable times for all supported days
            for day in self.supported_days:
                day_key = f'{day}_unavailable'
                student_profile[day_key] = self._parse_unavailable_times(student.get(day_key, ''))
            
            self.students_data.append(student_profile)
    
    def load_from_file(self, file_path: str, sheet_name=0):
        """Load data from CSV or Excel file"""
        file_path_lower = file_path.lower()
        try:
            if file_path_lower.endswith('.csv'):
                df = pd.read_csv(file_path)
            elif file_path_lower.endswith(('.xlsx', '.xls')):
                df = pd.read_excel(file_path, sheet_name=sheet_name)
            else:
                print("Unsupported file format. Please use .csv, .xlsx, or .xls files.")
                return False
            
            return self.load_from_dataframe(df)
        except Exception as e:
            print(f"Error loading file: {e}")
            return False
    
    def load_from_dataframe(self, df):
        """Load data from a pandas DataFrame"""
        students = []
        
        # Define possible column names
        column_mapping = {
            'proficient': ['Proficient Skills', 'proficient_skills'],
            'intermediate': ['Intermediate Skills', 'intermediate_skills'],
            'beginner': ['Beginner Skills', 'beginner_skills'],
            'name': ['Name', 'Student Name', 'name', 'student_name']
        }
        
        # Day-specific columns
        day_column_mapping = {}
        for day in self.supported_days:
            day_key = f'{day}_unavailable'
            day_column_mapping[day] = [
                f'Time Slots to Avoid [{day.capitalize()}]',
                f'{day.capitalize()} Unavailable',
                day_key
            ]
        
        # Find actual column names
        actual_columns = {}
        for key, possible_names in column_mapping.items():
            for col_name in df.columns:
                if col_name in possible_names:
                    actual_columns[key] = col_name
                    break
        
        actual_day_columns = {}
        for day, possible_names in day_column_mapping.items():
            for col_name in df.columns:
                if col_name in possible_names:
                    actual_day_columns[day] = col_name
                    break
        
        print(f"Found columns: {actual_columns}")
        print(f"Found day columns: {list(actual_day_columns.keys())}")
        
        # Process each row
        for i, row in df.iterrows():
            student = {
                'student_id': f'S{i+1:03d}',
                'name': row.get(actual_columns.get('name', ''), f'Student {i+1}'),
                'proficient_skills': row.get(actual_columns.get('proficient', ''), ''),
                'intermediate_skills': row.get(actual_columns.get('intermediate', ''), ''),
                'beginner_skills': row.get(actual_columns.get('beginner', ''), '')
            }
            
            # Add day-specific unavailable times
            for day in self.supported_days:
                day_key = f'{day}_unavailable'
                if day in actual_day_columns:
                    student[day_key] = row.get(actual_day_columns[day], '')
                else:
                    student[day_key] = ''  # Available all day
            
            students.append(student)
        
        self.load_student_data(students)
        print(f"Successfully loaded {len(students)} students")
        return True
    
    def get_available_slots(self, student_id: str, day: str) -> Set[str]:
        """Get available time slots for a student on a specific day"""
        student = next((s for s in self.students_data if s['student_id'] == student_id), None)
        if not student:
            return set()
        
        all_slots = set(self.time_slots)
        unavailable = student.get(f'{day.lower()}_unavailable', set())
        return all_slots - unavailable
    
    def find_team_availability(self, team_member_ids: List[str], preferred_days: List[str] = None, 
                              min_duration: int = 1, include_individual_availability: bool = False) -> Dict:
        """
        Find optimal meeting times for a specific team of students
        
        Args:
            team_member_ids: List of specific student IDs that form the team
            preferred_days: List of preferred days (default: all days)
            min_duration: Minimum meeting duration in hours
            include_individual_availability: Whether to include individual availability data
        
        Returns:
            Dictionary containing:
            - team_info: Basic team information
            - meeting_suggestions: List of available meeting times
            - team_compatibility: Overall team compatibility score
            - individual_availability: Individual member availability (if requested)
        """
        if not team_member_ids:
            return {'error': 'No team members provided'}
        
        # Validate all team members exist
        missing_members = []
        for member_id in team_member_ids:
            if not any(s['student_id'] == member_id for s in self.students_data):
                missing_members.append(member_id)
        
        if missing_members:
            return {'error': f'Team members not found: {missing_members}'}
        
        # Default to all days if not specified
        if preferred_days is None:
            preferred_days = self.supported_days
        else:
            preferred_days = [day.lower() for day in preferred_days if day.lower() in self.supported_days]
        
        # Get team member details
        team_members = [s for s in self.students_data if s['student_id'] in team_member_ids]
        
        print(f"🎯 Analyzing team of {len(team_member_ids)} members...")
        print(f"📅 Checking availability for: {[day.capitalize() for day in preferred_days]}")
        
        # Find common availability for each day
        meeting_suggestions = []
        
        for day in preferred_days:
            print(f"  Checking {day.capitalize()}...")
            
            # Find common time slots for all team members
            common_slots = self._find_common_availability(team_member_ids, day)
            
            if common_slots:
                # Find consecutive time blocks
                available_slots = sorted(list(common_slots))
                consecutive_groups = self._find_consecutive_slots(available_slots, min_duration)
                
                for slot_group in consecutive_groups:
                    suggestion = {
                        'day': day.capitalize(),
                        'start_time': slot_group[0].split(' - ')[0],
                        'end_time': slot_group[-1].split(' - ')[1],
                        'time_slots': slot_group,
                        'duration_hours': len(slot_group),
                        'available_members': len(team_member_ids),  # All members are available
                        'total_members': len(team_member_ids)
                    }
                    meeting_suggestions.append(suggestion)
        
        # Calculate team compatibility
        team_compatibility = self._calculate_team_compatibility(team_member_ids)
        
        # Prepare result
        result = {
            'team_info': {
                'member_ids': team_member_ids,
                'member_names': [m['name'] for m in team_members],
                'team_size': len(team_member_ids),
                'days_checked': [day.capitalize() for day in preferred_days]
            },
            'meeting_suggestions': sorted(meeting_suggestions, 
                                        key=lambda x: (x['duration_hours'], x['day']), 
                                        reverse=True),
            'team_compatibility': team_compatibility,
            'summary': {
                'total_meeting_options': len(meeting_suggestions),
                'best_day': self._get_best_day(meeting_suggestions),
                'longest_available_duration': max([s['duration_hours'] for s in meeting_suggestions], default=0)
            }
        }
        
        # Add individual availability if requested
        if include_individual_availability:
            individual_availability = {}
            for member_id in team_member_ids:
                member_availability = {}
                for day in preferred_days:
                    available_slots = self.get_available_slots(member_id, day)
                    member_availability[day] = {
                        'total_slots': len(available_slots),
                        'available_slots': sorted(list(available_slots))
                    }
                individual_availability[member_id] = member_availability
            result['individual_availability'] = individual_availability
        
        return result
    
    def _find_common_availability(self, student_ids: List[str], day: str) -> Set[str]:
        """Find time slots when ALL team members are available"""
        if not student_ids:
            return set()
        
        common_slots = self.get_available_slots(student_ids[0], day)
        for student_id in student_ids[1:]:
            student_availability = self.get_available_slots(student_id, day)
            common_slots = common_slots.intersection(student_availability)
        
        return common_slots
    
    def _find_consecutive_slots(self, slots: List[str], min_duration: int) -> List[List[str]]:
        """Find consecutive time slots that meet minimum duration requirement"""
        if not slots:
            return []
        
        slot_to_hour = {}
        for slot in slots:
            hour = int(slot.split(':')[0])
            slot_to_hour[slot] = hour
        
        sorted_slots = sorted(slots, key=lambda x: slot_to_hour[x])
        consecutive_groups = []
        current_group = [sorted_slots[0]]
        
        for i in range(1, len(sorted_slots)):
            current_hour = slot_to_hour[sorted_slots[i]]
            prev_hour = slot_to_hour[sorted_slots[i-1]]
            
            if current_hour == prev_hour + 1:
                current_group.append(sorted_slots[i])
            else:
                if len(current_group) >= min_duration:
                    consecutive_groups.append(current_group)
                current_group = [sorted_slots[i]]
        
        if len(current_group) >= min_duration:
            consecutive_groups.append(current_group)
        
        return consecutive_groups
    
    def _calculate_team_compatibility(self, student_ids: List[str]) -> Dict:
        """Calculate overall compatibility metrics for the team"""
        if len(student_ids) <= 1:
            return {'overall_score': 1.0, 'pairwise_scores': {}, 'team_skills_analysis': {}}
        
        # Calculate pairwise compatibility
        pairwise_scores = {}
        total_score = 0
        pair_count = 0
        
        for i in range(len(student_ids)):
            for j in range(i + 1, len(student_ids)):
                score = self._calculate_skill_compatibility(student_ids[i], student_ids[j])
                pairwise_scores[f"{student_ids[i]}-{student_ids[j]}"] = score
                total_score += score
                pair_count += 1
        
        overall_score = total_score / pair_count if pair_count > 0 else 0.0
        
        # Analyze team skills
        team_skills_analysis = self._analyze_team_skills(student_ids)
        
        return {
            'overall_score': overall_score,
            'pairwise_scores': pairwise_scores,
            'team_skills_analysis': team_skills_analysis
        }
    
    def _calculate_skill_compatibility(self, student1_id: str, student2_id: str) -> float:
        """Calculate skill compatibility between two students"""
        student1 = next((s for s in self.students_data if s['student_id'] == student1_id), None)
        student2 = next((s for s in self.students_data if s['student_id'] == student2_id), None)
        
        if not student1 or not student2:
            return 0.0
        
        s1_all_skills = set(student1['proficient_skills'] + student1['intermediate_skills'] + student1['beginner_skills'])
        s2_all_skills = set(student2['proficient_skills'] + student2['intermediate_skills'] + student2['beginner_skills'])
        
        s1_strong = set(student1['proficient_skills'] + student1['intermediate_skills'])
        s2_strong = set(student2['proficient_skills'] + student2['intermediate_skills'])
        s1_weak = set(student1['beginner_skills'])
        s2_weak = set(student2['beginner_skills'])
        
        # Complementary skills (teaching opportunities)
        complementary_score = len(s1_strong.intersection(s2_weak)) + len(s2_strong.intersection(s1_weak))
        
        # Common skills (shared interests)
        common_skills = len(s1_all_skills.intersection(s2_all_skills))
        
        # Normalize scores
        max_possible_complementary = min(len(s1_strong), len(s2_weak)) + min(len(s2_strong), len(s1_weak))
        max_possible_common = min(len(s1_all_skills), len(s2_all_skills))
        
        complementary_norm = complementary_score / max_possible_complementary if max_possible_complementary > 0 else 0
        common_norm = common_skills / max_possible_common if max_possible_common > 0 else 0
        
        # Weighted combination
        compatibility = 0.7 * complementary_norm + 0.3 * common_norm
        return min(compatibility, 1.0)
    
    def _analyze_team_skills(self, student_ids: List[str]) -> Dict:
        """Analyze the skill distribution within the team"""
        all_skills = set()
        skill_levels = {'proficient': set(), 'intermediate': set(), 'beginner': set()}
        
        for student_id in student_ids:
            student = next((s for s in self.students_data if s['student_id'] == student_id), None)
            if student:
                for skill in student['proficient_skills']:
                    all_skills.add(skill)
                    skill_levels['proficient'].add(skill)
                for skill in student['intermediate_skills']:
                    all_skills.add(skill)
                    skill_levels['intermediate'].add(skill)
                for skill in student['beginner_skills']:
                    all_skills.add(skill)
                    skill_levels['beginner'].add(skill)
        
        return {
            'total_unique_skills': len(all_skills),
            'skills_by_level': {
                'proficient': list(skill_levels['proficient']),
                'intermediate': list(skill_levels['intermediate']),
                'beginner': list(skill_levels['beginner'])
            },
            'skill_coverage': list(all_skills)
        }
    
    def _get_best_day(self, meeting_suggestions: List[Dict]) -> str:
        """Find the day with the most meeting options"""
        if not meeting_suggestions:
            return "None"
        
        day_counts = {}
        for suggestion in meeting_suggestions:
            day = suggestion['day']
            day_counts[day] = day_counts.get(day, 0) + 1
        
        return max(day_counts, key=day_counts.get) if day_counts else "None"
    
    def create_random_team(self, team_size: int, seed: int = None) -> List[str]:
        """
        Create a random team of specified size for testing purposes
        
        Args:
            team_size: Number of team members
            seed: Random seed for reproducible results
        
        Returns:
            List of student IDs forming the random team
        """
        if seed is not None:
            random.seed(seed)
        
        if team_size > len(self.students_data):
            print(f"Warning: Requested team size ({team_size}) larger than available students ({len(self.students_data)})")
            team_size = len(self.students_data)
        
        all_student_ids = [s['student_id'] for s in self.students_data]
        random_team = random.sample(all_student_ids, team_size)
        
        print(f"🎲 Created random team of {team_size} members: {random_team}")
        return random_team
    
    def print_summary(self):
        """Print a summary of loaded data"""
        print(f"📊 SCHOLARX TEAM SCHEDULER SUMMARY")
        print(f"=" * 45)
        print(f"Total Students Available: {len(self.students_data)}")
        print(f"Supported Days: {[day.capitalize() for day in self.supported_days]}")
        print(f"Time Slots per Day: {len(self.time_slots)} (9 AM - 12 AM)")
        
        if self.students_data:
            print(f"Student IDs: {[s['student_id'] for s in self.students_data[:5]]}" + 
                  ("..." if len(self.students_data) > 5 else ""))
        
        print(f"=" * 45)


# Usage example with your actual data
def test_with_real_data():
    """
    Test the scheduler with your actual Excel data file
    """
    print("🚀 TESTING WITH YOUR REAL DATA")
    print("=" * 50)
    
    scheduler = ScholarXScheduler()
    
    # Load your actual data file - UPDATE THIS PATH
    file_path = "C:/Users/vijay/Desktop/Infinity/Final year project/AI_DS_Student_Scheduling_Data.xlsx"
    
    print(f"📂 Loading data from: {file_path}")
    
    if scheduler.load_from_file(file_path):
        scheduler.print_summary()
        
        # Example 1: Analyze first 3 students as a team
        if len(scheduler.students_data) >= 3:
            print(f"\n🎯 ANALYZING TEAM OF FIRST 3 STUDENTS")
            team_ids = [s['student_id'] for s in scheduler.students_data[:3]]
            
            result = scheduler.find_team_availability(
                team_member_ids=team_ids,
                preferred_days=['monday', 'tuesday', 'wednesday', 'thursday', 'friday'],
                min_duration=2
            )
            
            if 'error' not in result:
                print(f"\n📋 Team Analysis Results:")
                print(f"Team Members: {result['team_info']['member_names']}")
                print(f"Team Compatibility Score: {result['team_compatibility']['overall_score']:.3f}")
                print(f"Total Meeting Options: {result['summary']['total_meeting_options']}")
                print(f"Best Day: {result['summary']['best_day']}")
                
                print(f"\n⏰ Available Meeting Times:")
                for i, suggestion in enumerate(result['meeting_suggestions'][:5]):
                    print(f"  {i+1}. {suggestion['day']} {suggestion['start_time']}-{suggestion['end_time']} "
                          f"({suggestion['duration_hours']}h)")
            else:
                print(f"❌ Error: {result['error']}")
        
        # Example 2: Test with random team for demo
        print(f"\n🎲 TESTING WITH RANDOM TEAM")
        if len(scheduler.students_data) >= 4:
            random_team = scheduler.create_random_team(team_size=4, seed=42)
            
            weekend_result = scheduler.find_team_availability(
                team_member_ids=random_team,
                preferred_days=['saturday', 'sunday'],
                min_duration=1
            )
            
            if 'error' not in weekend_result:
                print(f"Random Team: {weekend_result['team_info']['member_names']}")
                print(f"Weekend Meeting Options: {weekend_result['summary']['total_meeting_options']}")
                
                if weekend_result['meeting_suggestions']:
                    best_option = weekend_result['meeting_suggestions'][0]
                    print(f"Best Weekend Option: {best_option['day']} {best_option['start_time']}-{best_option['end_time']}")
    else:
        print("❌ Failed to load data file. Please check the file path.")


# Simple function to demonstrate core functionality
def demo_team_scheduling(team_member_ids, preferred_days=None, min_duration=1):
    """
    Simple demo function - you can use this pattern in your app
    
    Args:
        team_member_ids: List of student IDs
        preferred_days: Days to check (optional)
        min_duration: Minimum meeting duration
    
    Returns:
        Meeting suggestions for the team
    """
    scheduler = ScholarXScheduler()
    
    # Load your data
    file_path = "C:/Users/vijay/Desktop/Infinity/Final year project/AI_DS_Student_Scheduling_Data.xlsx"
    
    if scheduler.load_from_file(file_path):
        result = scheduler.find_team_availability(
            team_member_ids=team_member_ids,
            preferred_days=preferred_days,
            min_duration=min_duration
        )
        return result
    else:
        return {'error': 'Failed to load data file'}


if __name__ == "__main__":
    test_with_real_data()