import pandas as pd
from typing import List, Dict, Set, Optional
from collections import defaultdict
import itertools
from pathlib import Path

class AutoRecommendScheduleMatcher:
    """
    Auto-Recommendation Schedule Matcher for Team Formation
    
    Features:
    - Automatic teammate recommendation based on schedule compatibility
    - User only specifies team size (number of teammates wanted)
    - Smart algorithm finds best schedule matches
    - Support for CSV/Excel data loading
    - Available/Avoid time slot logic
    """
    
    def __init__(self):
        self.time_slots = [
            "09:00 - 11:00", "11:00 - 13:00", "13:00 - 15:00", "15:00 - 17:00",
            "17:00 - 19:00", "19:00 - 21:00", "21:00 - 23:00", "00:00 - 01:00"
        ]
        self.days = ['monday', 'tuesday', 'wednesday', 'thursday', 'friday', 'saturday', 'sunday']
        self.users_data = {}
        self.user_list = []
    
    def load_from_file(self, file_path: str, sheet_name=0) -> bool:
        """Load user schedule data from CSV or Excel file"""
        try:
            # Handle both relative and absolute paths
            if not Path(file_path).exists():
                # Try different path variations
                possible_paths = [
                    file_path,
                    Path.cwd() / file_path,
                    Path.cwd() / "SCHOLARX" / file_path,
                    Path.cwd() / file_path.split('/')[-1],  # Just filename
                    Path.cwd() / file_path.split('\\')[-1]  # Just filename (Windows)
                ]
                
                found_path = None
                for path in possible_paths:
                    if Path(path).exists():
                        found_path = path
                        break
                
                if not found_path:
                    print(f"File not found. Tried these locations:")
                    for path in possible_paths[:3]:
                        print(f"  - {path}")
                    return False
                
                file_path = found_path
            
            file_path = Path(file_path)
            print(f"Loading file: {file_path}")
            
            if file_path.suffix.lower() == '.csv':
                df = pd.read_csv(file_path)
            elif file_path.suffix.lower() in ['.xlsx', '.xls']:
                df = pd.read_excel(file_path, sheet_name=sheet_name)
            else:
                print("Unsupported file format. Please use .csv, .xlsx, or .xls files.")
                return False
            
            return self._process_dataframe(df)
            
        except Exception as e:
            print(f"Error loading file: {e}")
            print(f"Make sure the file exists and is readable.")
            return False
    
    def _process_dataframe(self, df: pd.DataFrame) -> bool:
        """Process DataFrame and extract user schedule data"""
        
        # Find relevant columns
        name_cols = ['Name', 'Student Name', 'name', 'student_name']
        id_cols = ['ID', 'Student ID', 'id', 'student_id', 'user_id']
        
        name_col = next((col for col in df.columns if col in name_cols), None)
        id_col = next((col for col in df.columns if col in id_cols), None)
        
        if not name_col and not id_col:
            print("No name or ID column found. Using row indices.")
        
        self.users_data = {}
        self.user_list = []
        
        for i, row in df.iterrows():
            # Generate user ID and name
            user_id = row.get(id_col, f'S{i+1:03d}') if id_col else f'S{i+1:03d}'
            
            # Fix name extraction - convert to string and handle NaN
            if name_col and not pd.isna(row.get(name_col)):
                user_name = str(row.get(name_col)).strip()
            else:
                user_name = f'User {i+1}'
            
            # If name is still a number or empty, create a proper name
            if user_name.isdigit() or user_name == '' or user_name == 'nan':
                user_name = f'Student {i+1}'
            
            user_data = {
                'name': str(user_name),
                'schedule': {}
            }
            
            # Process schedule for each day
            for day in self.days:
                available_raw = self._find_day_column(df.columns, day, 'available', row)
                avoid_raw = self._find_day_column(df.columns, day, 'avoid', row)
                
                available_slots = self._parse_time_slots(available_raw)
                avoid_slots = self._parse_time_slots(avoid_raw)
                
                # Default: if no available slots specified, all slots are available
                if not available_slots:
                    available_slots = set(self.time_slots)
                
                # Valid slots = Available - Avoid
                valid_slots = available_slots - avoid_slots
                
                user_data['schedule'][day] = {
                    'available': available_slots,
                    'avoid': avoid_slots,
                    'valid': valid_slots
                }
            
            self.users_data[str(user_id)] = user_data
            self.user_list.append({'id': str(user_id), 'name': str(user_name)})
        
        print(f"Successfully loaded {len(self.users_data)} users")
        return True
    
    def _find_day_column(self, columns, day: str, slot_type: str, row) -> str:
        """Find and extract data from day-specific columns"""
        possible_patterns = [
            f'{day.capitalize()} {slot_type.capitalize()}',
            f'{slot_type.capitalize()} Time Slots [{day.capitalize()}]',
            f'Time Slots {slot_type.capitalize()} [{day.capitalize()}]',
            f'{day}_{slot_type}',
            f'{day.capitalize()}_{slot_type.capitalize()}'
        ]
        
        for pattern in possible_patterns:
            if pattern in columns:
                return str(row.get(pattern, ''))
        
        return ''
    
    def _parse_time_slots(self, time_string: str) -> Set[str]:
        """Parse comma-separated time slots into standardized format"""
        if not time_string or pd.isna(time_string) or time_string.strip() == '':
            return set()
        
        parsed_slots = set()
        slots = str(time_string).split(',')
        
        for slot in slots:
            slot = slot.strip()
            if slot:
                normalized = self._normalize_time_slot(slot)
                if normalized in self.time_slots:
                    parsed_slots.add(normalized)
        
        return parsed_slots
    
    def _normalize_time_slot(self, time_slot: str) -> str:
        """Convert various time formats to standard format"""
        if not time_slot:
            return ""
        
        time_slot = time_slot.strip()
        
        # Direct match first
        if time_slot in self.time_slots:
            return time_slot
        
        # Common format mappings
        mappings = {
            "9-11": "09:00 - 11:00", "9am-11am": "09:00 - 11:00", "09:00-11:00": "09:00 - 11:00",
            "11-13": "11:00 - 13:00", "11am-1pm": "11:00 - 13:00", "11:00-13:00": "11:00 - 13:00",
            "13-15": "13:00 - 15:00", "1pm-3pm": "13:00 - 15:00", "13:00-15:00": "13:00 - 15:00",
            "15-17": "15:00 - 17:00", "3pm-5pm": "15:00 - 17:00", "15:00-17:00": "15:00 - 17:00",
            "17-19": "17:00 - 19:00", "5pm-7pm": "17:00 - 19:00", "17:00-19:00": "17:00 - 19:00",
            "19-21": "19:00 - 21:00", "7pm-9pm": "19:00 - 21:00", "19:00-21:00": "19:00 - 21:00",
            "21-23": "21:00 - 23:00", "9pm-11pm": "21:00 - 23:00", "21:00-23:00": "21:00 - 23:00",
            "0-1": "00:00 - 01:00", "12am-1am": "00:00 - 01:00", "00:00-01:00": "00:00 - 01:00"
        }
        
        # Try normalized comparison
        normalized_input = time_slot.lower().replace(" ", "").replace(":", "")
        for pattern, standard in mappings.items():
            if normalized_input == pattern.replace(" ", "").replace(":", ""):
                return standard
        
        return time_slot
    
    def get_team_preferences(self) -> Dict:
        """Get user preferences for team formation"""
        print("TEAM FORMATION PREFERENCES")
        print("=" * 40)
        
        if not self.user_list:
            return {'error': 'No users loaded. Please load data first.'}
        
        print(f"Available users: {len(self.user_list)}")
        
        # Get team size
        while True:
            try:
                team_size = int(input(f"How many people in your team? (2-{min(8, len(self.user_list))}): "))
                if 2 <= team_size <= min(8, len(self.user_list)):
                    break
                else:
                    print(f"Please enter a number between 2 and {min(8, len(self.user_list))}")
            except ValueError:
                print("Please enter a valid number")
            except KeyboardInterrupt:
                return {'error': 'User cancelled selection'}
        
        # Get day preferences
        print("\nDAY PREFERENCES")
        print("Available days: Monday, Tuesday, Wednesday, Thursday, Friday, Saturday, Sunday")
        print("Enter day numbers (1-7) separated by commas, or 'all' for all days:")
        print("1=Monday, 2=Tuesday, 3=Wednesday, 4=Thursday, 5=Friday, 6=Saturday, 7=Sunday")
        
        while True:
            try:
                day_input = input("Your choice: ").strip().lower()
                
                if day_input == 'all':
                    selected_days = self.days
                    break
                else:
                    day_numbers = [int(x.strip()) for x in day_input.split(',')]
                    selected_days = []
                    for num in day_numbers:
                        if 1 <= num <= 7:
                            selected_days.append(self.days[num-1])
                    
                    if not selected_days:
                        print("No valid days selected. Please try again.")
                        continue
                    break
                        
            except ValueError:
                print("Invalid input format. Please use numbers 1-7 separated by commas, or 'all'")
            except KeyboardInterrupt:
                return {'error': 'User cancelled selection'}
        
        return {
            'team_size': team_size,
            'preferred_days': selected_days
        }
    
    def find_best_teams(self, team_size: int, preferred_days: List[str], num_recommendations: int = 5) -> List[Dict]:
        """Find the best teams based on schedule compatibility"""
        print(f"\nAnalyzing {len(self.user_list)} users for optimal {team_size}-person teams...")
        
        all_user_ids = list(self.users_data.keys())
        best_teams = []
        
        # Calculate total possible combinations for progress tracking
        from math import comb
        total_combinations = comb(len(all_user_ids), team_size)
        
        if total_combinations > 1000:
            print(f"Large search space detected ({total_combinations:,} combinations).")
            print("Using smart sampling for faster results...")
            # Use sampling for large datasets
            import random
            sample_size = min(1000, total_combinations)
            combinations = random.sample(list(itertools.combinations(all_user_ids, team_size)), sample_size)
        else:
            print(f"Checking all {total_combinations:,} possible combinations...")
            combinations = itertools.combinations(all_user_ids, team_size)
        
        # Analyze each combination
        processed = 0
        for team_ids in combinations:
            team_score = self._calculate_team_score(list(team_ids), preferred_days)
            
            if team_score['total_slots'] > 0:  # Only consider teams with meeting options
                best_teams.append({
                    'user_ids': list(team_ids),
                    'user_names': [self.users_data[uid]['name'] for uid in team_ids],
                    'total_meeting_slots': team_score['total_slots'],
                    'perfect_days': team_score['perfect_days'],
                    'partial_availability': team_score['partial_slots'],
                    'compatibility_score': team_score['score'],
                    'day_breakdown': team_score['day_breakdown']
                })
            
            processed += 1
            if processed % 100 == 0 and total_combinations > 100:
                progress = (processed / min(1000, total_combinations)) * 100
                print(f"Progress: {progress:.1f}%")
        
        # Sort teams by compatibility score (descending)
        best_teams.sort(key=lambda x: (-x['compatibility_score'], -x['total_meeting_slots']))
        
        print(f"Found {len(best_teams)} compatible teams out of {processed} combinations checked.")
        
        return best_teams[:num_recommendations]
    
    def _calculate_team_score(self, user_ids: List[str], preferred_days: List[str]) -> Dict:
        """Calculate comprehensive compatibility score for a team"""
        total_slots = 0
        perfect_days = 0
        partial_slots = 0
        day_breakdown = {}
        
        for day in preferred_days:
            # Find perfect slots (100% availability)
            perfect_slots = self._find_common_slots(user_ids, day)
            perfect_count = len(perfect_slots)
            
            # Find partial slots (majority availability)
            partial_count = 0
            min_participants = max(2, len(user_ids) - 1)  # At least majority
            
            for slot in self.time_slots:
                available_count = sum(1 for uid in user_ids 
                                    if slot in self.users_data[uid]['schedule'][day]['valid'])
                if available_count >= min_participants and available_count < len(user_ids):
                    partial_count += 1
            
            day_breakdown[day] = {
                'perfect_slots': perfect_count,
                'partial_slots': partial_count,
                'total_slots': perfect_count + partial_count
            }
            
            total_slots += perfect_count
            partial_slots += partial_count
            
            if perfect_count > 0:
                perfect_days += 1
        
        # Calculate weighted compatibility score
        # Perfect slots worth more than partial slots
        score = (total_slots * 10) + (partial_slots * 3) + (perfect_days * 5)
        
        return {
            'total_slots': total_slots,
            'perfect_days': perfect_days,
            'partial_slots': partial_slots,
            'score': score,
            'day_breakdown': day_breakdown
        }
    
    def _find_common_slots(self, user_ids: List[str], day: str) -> Set[str]:
        """Find time slots where ALL users are available"""
        if not user_ids:
            return set()
        
        # Start with first user's valid slots
        common_slots = self.users_data[user_ids[0]]['schedule'][day]['valid'].copy()
        
        # Find intersection with all other users
        for user_id in user_ids[1:]:
            user_valid_slots = self.users_data[user_id]['schedule'][day]['valid']
            common_slots = common_slots.intersection(user_valid_slots)
        
        return common_slots
    
    def display_team_recommendations(self, teams: List[Dict], preferences: Dict):
        """Display team recommendations in a user-friendly format"""
        if not teams:
            print("\nNo compatible teams found with your criteria.")
            print("Try:")
            print("- Reducing team size")
            print("- Including more days")
            print("- Checking if users have sufficient schedule data")
            return
        
        print(f"\nTOP {len(teams)} RECOMMENDED TEAMS")
        print("=" * 60)
        print(f"Criteria: {preferences['team_size']} people, Days: {[d.capitalize() for d in preferences['preferred_days']]}")
        print()
        
        for i, team in enumerate(teams, 1):
            print(f"RECOMMENDATION #{i}")
            print("-" * 30)
            print(f"Team: {', '.join(team['user_names'])}")
            print(f"Meeting options: {team['total_meeting_slots']} perfect slots")
            
            if team['perfect_days'] > 0:
                print(f"Days with meetings: {team['perfect_days']}")
            
            if team['partial_availability'] > 0:
                print(f"Partial availability slots: {team['partial_availability']}")
            
            print(f"Compatibility score: {team['compatibility_score']}")
            
            # Show day breakdown
            print("Day-by-day breakdown:")
            for day, breakdown in team['day_breakdown'].items():
                if breakdown['total_slots'] > 0:
                    print(f"  {day.capitalize()}: {breakdown['perfect_slots']} perfect"
                          + (f", {breakdown['partial_slots']} partial" if breakdown['partial_slots'] > 0 else ""))
            
            print()
    
    def find_meeting_times_for_team(self, team: Dict, preferred_days: List[str]) -> Dict:
        """Find detailed meeting times for a recommended team"""
        return self.find_meeting_times(team['user_ids'], preferred_days)
    
    def find_meeting_times(self, user_ids: List[str], preferred_days: List[str] = None) -> Dict:
        """Find optimal meeting times for selected users"""
        if len(user_ids) < 2:
            return {'error': 'Need at least 2 users to schedule a meeting'}
        
        # Validate users exist
        missing_users = [uid for uid in user_ids if uid not in self.users_data]
        if missing_users:
            return {'error': f'Users not found: {missing_users}'}
        
        if preferred_days is None:
            preferred_days = self.days
        
        meeting_suggestions = []
        day_statistics = {}
        
        # Find meetings for each day
        for day in preferred_days:
            common_slots = self._find_common_slots(user_ids, day)
            day_statistics[day] = len(common_slots)
            
            for slot in sorted(common_slots):
                start_time, end_time = slot.split(' - ')
                meeting_suggestions.append({
                    'day': day.capitalize(),
                    'time_slot': slot,
                    'start_time': start_time,
                    'end_time': end_time,
                    'duration_hours': 2,
                    'participants': len(user_ids),
                    'availability': 100.0
                })
        
        # Find backup options (partial availability)
        backup_suggestions = self._find_partial_availability(user_ids, preferred_days)
        
        # Statistics
        total_options = len(meeting_suggestions)
        best_day = max(day_statistics.keys(), key=day_statistics.get) if day_statistics else "None"
        
        return {
            'team_info': {
                'user_ids': user_ids,
                'user_names': [self.users_data[uid]['name'] for uid in user_ids],
                'team_size': len(user_ids),
                'days_checked': [day.capitalize() for day in preferred_days]
            },
            'meeting_suggestions': meeting_suggestions,
            'backup_suggestions': backup_suggestions,
            'statistics': {
                'total_meeting_options': total_options,
                'best_day': best_day.capitalize() if best_day != "None" else "None",
                'options_per_day': {day.capitalize(): count for day, count in day_statistics.items()},
                'success_rate': "100%" if total_options > 0 else "0%"
            }
        }
    
    def _find_partial_availability(self, user_ids: List[str], days: List[str]) -> List[Dict]:
        """Find backup slots with partial team availability"""
        backup_slots = []
        min_participants = max(2, len(user_ids) - 1)  # At least majority
        
        for day in days:
            for slot in self.time_slots:
                available_users = []
                for user_id in user_ids:
                    if slot in self.users_data[user_id]['schedule'][day]['valid']:
                        available_users.append(user_id)
                
                if len(available_users) >= min_participants:
                    start_time, end_time = slot.split(' - ')
                    backup_slots.append({
                        'day': day.capitalize(),
                        'time_slot': slot,
                        'start_time': start_time,
                        'end_time': end_time,
                        'duration_hours': 2,
                        'participants': len(available_users),
                        'availability': (len(available_users) / len(user_ids)) * 100,
                        'available_users': [self.users_data[uid]['name'] for uid in available_users],
                        'unavailable_users': [self.users_data[uid]['name'] for uid in user_ids if uid not in available_users]
                    })
        
        # Sort by availability percentage
        backup_slots.sort(key=lambda x: (-x['availability'], x['day'], x['start_time']))
        
        return backup_slots[:10]  # Top 10 backup options
    
    def print_meeting_results(self, result: Dict):
        """Pretty print meeting results"""
        if 'error' in result:
            print(f"Error: {result['error']}")
            return
        
        print("\nDETAILED MEETING SCHEDULE")
        print("=" * 50)
        
        # Team info
        team_info = result['team_info']
        print(f"Team: {', '.join(team_info['user_names'])}")
        print(f"Team size: {team_info['team_size']}")
        print(f"Days checked: {', '.join(team_info['days_checked'])}")
        
        # Statistics
        stats = result['statistics']
        print(f"\nMeeting options: {stats['total_meeting_options']}")
        print(f"Best day: {stats['best_day']}")
        print(f"Success rate: {stats['success_rate']}")
        
        if stats['options_per_day']:
            print(f"Options per day: {dict(stats['options_per_day'])}")
        
        # Perfect meetings
        meetings = result['meeting_suggestions']
        if meetings:
            print(f"\nPERFECT MEETING TIMES (100% availability):")
            for i, meeting in enumerate(meetings[:8], 1):
                print(f"  {i:2d}. {meeting['day']} {meeting['start_time']}-{meeting['end_time']}")
        else:
            print(f"\nNo perfect meeting times found.")
        
        # Backup options
        backups = result['backup_suggestions']
        if backups and not meetings:
            print(f"\nBACKUP OPTIONS (partial availability):")
            for i, backup in enumerate(backups[:5], 1):
                print(f"  {i:2d}. {backup['day']} {backup['start_time']}-{backup['end_time']} "
                      f"({backup['availability']:.0f}% available)")
                if backup['unavailable_users']:
                    print(f"      Missing: {', '.join(backup['unavailable_users'])}")
    
    def run_interactive_session(self):
        """Run complete interactive session with automatic recommendations"""
        print("AUTO-RECOMMENDATION SCHEDULE MATCHER")
        print("=" * 50)
        
        if not self.users_data:
            print("No data loaded. Please load your data file first.")
            return
        
        print(f"Loaded {len(self.users_data)} users successfully.")
        
        while True:
            # Get user preferences
            preferences = self.get_team_preferences()
            
            if 'error' in preferences:
                print(f"Error: {preferences['error']}")
                return
            
            # Find best teams automatically
            recommended_teams = self.find_best_teams(
                team_size=preferences['team_size'],
                preferred_days=preferences['preferred_days'],
                num_recommendations=5
            )
            
            # Display recommendations
            self.display_team_recommendations(recommended_teams, preferences)
            
            if not recommended_teams:
                continue_choice = input("Try different criteria? (y/n): ").strip().lower()
                if continue_choice != 'y':
                    break
                continue
            
            # Let user select a team for detailed schedule
            print("\nWould you like to see detailed meeting times for any team?")
            print("Enter team number (1-{}) or 'skip' to try new criteria: ".format(len(recommended_teams)))
            
            user_choice = input("Your choice: ").strip().lower()
            
            if user_choice == 'skip':
                continue_choice = input("Try different criteria? (y/n): ").strip().lower()
                if continue_choice != 'y':
                    break
                continue
            
            try:
                team_num = int(user_choice)
                if 1 <= team_num <= len(recommended_teams):
                    selected_team = recommended_teams[team_num - 1]
                    
                    print(f"\nSelected Team: {', '.join(selected_team['user_names'])}")
                    
                    # Get detailed meeting times
                    meeting_result = self.find_meeting_times_for_team(
                        selected_team, 
                        preferences['preferred_days']
                    )
                    
                    # Display detailed results
                    self.print_meeting_results(meeting_result)
                else:
                    print("Invalid team number.")
            except ValueError:
                print("Invalid input.")
            
            # Ask to continue
            print(f"\n" + "="*50)
            continue_choice = input("Find another team? (y/n): ").strip().lower()
            
            if continue_choice != 'y':
                print("Thank you for using Auto-Recommendation Schedule Matcher!")
                break


# Main execution function
def main():
    """Main function to run the auto-recommendation schedule matcher"""
    matcher = AutoRecommendScheduleMatcher()
    
    print("AUTO-RECOMMENDATION SCHEDULE MATCHER")
    print("=" * 50)
    
    # Try to load common file names first
    common_files = [
        "Cleaned_ScholarX_Data_NoConflicts.xlsx",
        "SCHOLARX/Cleaned_ScholarX_Data_NoConflicts.xlsx", 
        "Cleaned_ScholarX_Data_Filled.xlsx",
        "data.xlsx",
        "schedule_data.csv"
    ]
    
    loaded = False
    for file_name in common_files:
        if matcher.load_from_file(file_name):
            loaded = True
            break
    
    # If no common file found, ask user
    if not loaded:
        while True:
            file_path = input("Enter your data file path (CSV or Excel): ").strip()
            if file_path and matcher.load_from_file(file_path):
                break
            else:
                print("Failed to load file. Please check the path and try again.")
                retry = input("Try again? (y/n): ").strip().lower()
                if retry != 'y':
                    return
    
    # Run interactive session
    matcher.run_interactive_session()


# Alternative function to load file directly in code
def load_with_specific_file(file_path: str):
    """Load matcher with a specific file path"""
    matcher = AutoRecommendScheduleMatcher()
    
    print("AUTO-RECOMMENDATION SCHEDULE MATCHER")
    print("=" * 50)
    
    if matcher.load_from_file(file_path):
        matcher.run_interactive_session()
    else:
        print(f"Failed to load file: {file_path}")

if __name__ == "__main__":
    main()